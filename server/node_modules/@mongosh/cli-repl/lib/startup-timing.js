"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTimingData = exports.markTime = exports.summariseTimingData = void 0;
const types_1 = require("@mongosh/types");
const jsTimingEntries = [];
function linkTimingInterface() {
    const boxedNode = process.boxednode;
    if (boxedNode) {
        return {
            markTime: boxedNode.markTime,
            getTimingData: boxedNode.getTimingData,
        };
    }
    return {
        markTime: (category, label) => jsTimingEntries.push([category, label, process.hrtime.bigint()]),
        getTimingData: () => {
            const data = jsTimingEntries.sort((a, b) => Number(a[2] - b[2]));
            return data.map(([category, label, time]) => [
                category,
                label,
                Number(time - data[0][2]),
            ]);
        },
    };
}
function summariseTimingData(timingData) {
    const durationByCategory = new Map();
    let lastTimestamp = 0;
    for (const [category, _, time] of timingData) {
        const durationInNs = time - lastTimestamp;
        const durationInMs = durationInNs / 1000000;
        const durationSum = (durationByCategory.get(category) || 0) + durationInMs;
        durationByCategory.set(category, durationSum);
        lastTimestamp = time;
    }
    return Object.fromEntries(durationByCategory.entries());
}
exports.summariseTimingData = summariseTimingData;
const timing = linkTimingInterface();
exports.markTime = timing.markTime;
exports.getTimingData = timing.getTimingData;
if (process.env.MONGOSH_SHOW_TIMING_DATA) {
    process.on('exit', function () {
        const rawTimingData = (0, exports.getTimingData)();
        if (process.env.MONGOSH_SHOW_TIMING_DATA === 'json') {
            console.log(JSON.stringify(rawTimingData));
        }
        else {
            console.table(rawTimingData.map(([category, label, time], i) => [
                category,
                label,
                `${(time / 1000000).toFixed(2)}ms`,
                i > 0
                    ? `+${((time - rawTimingData[i - 1][2]) / 1000000).toFixed(2)}ms`
                    : '',
            ]));
        }
    });
}
(0, exports.markTime)(types_1.TimingCategories.REPLInstantiation, 'cli-repl timing initialized');
//# sourceMappingURL=startup-timing.js.map